import type { ChatCompletionMessageParam } from 'openai/resources/chat/completions';
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import * as z from 'zod';

export declare class Agent {
    static name: string;
    static description: string;
    protected options: AgentOptions;
    protected logger: RunnerLogger;
    protected workingDir: string;
    protected session: Session;
    constructor(options: AgentOptions);
    /**
     * Execute the agent with the given prompt.
     * This method runs the full agentic loop with the execution engine.
     *
     * @param prompt - The user's prompt/instruction
     * @returns AsyncGenerator of SDKEvent objects
     */
    query(prompt: string): AsyncGenerator<SDKEvent>;
    /**
     * Build agent model string from provider config
     */
    private buildAgentModelString;
    /**
     * Apply tool filtering based on allowedTools/disabledTools
     */
    private applyToolFiltering;
    /**
     * Translate internal Event objects to SDK events
     */
    private translateEvent;
}

export declare interface AgentOptions {
    modelProvider: ModelProvider;
    session?: Session;
    abortController?: AbortController;
    allowedTools?: string[];
    disabledTools?: string[];
    requestPermission?: (permissionRequest: PermissionRequest) => Promise<PermissionRequestResult>;
    mcpServers?: Record<string, MCPServerConfig>;
    hooks?: QueryHooks;
    logger?: RunnerLogger;
    workingDirectory?: string;
    env?: Record<string, string>;
    additionalDirectories?: string[];
    integrationId?: string;
    hmacKey?: string;
    copilotToken?: string;
}

/**
 * Base interface for all hook inputs
 */
export declare interface BaseHookInput {
    timestamp: number;
    cwd: string;
}

export declare abstract class BaseLogger implements RunnerLogger {
    protected logLevel?: LogLevel;
    protected debugEnvironmentVariables?: string[];
    private secretFilter;
    constructor(logLevel?: LogLevel, debugEnvironmentVariables?: string[]);
    filterSecrets(messageOrError: string | Error): string | Error;
    /**
     * Returns true if the log level is not set, or the log level is set and the level is enabled.
     */
    shouldLog(level: LogLevel): boolean;
    isDebug(): boolean;
    abstract log(message: string): void;
    abstract info(message: string): void;
    abstract debug(message: string): void;
    abstract notice(message: string | Error): void;
    abstract warning(message: string | Error): void;
    abstract error(message: string | Error): void;
    abstract startGroup(name: string, level?: LogLevel): void;
    abstract endGroup(level?: LogLevel): void;
}

declare type BinaryResult = {
    data: string;
    mimeType: string;
    type: string;
};

declare type Command = {
    readonly identifier: string;
    readonly readOnly: boolean;
};

export declare class CompoundLogger implements RunnerLogger {
    readonly loggers: RunnerLogger[];
    constructor(loggers: RunnerLogger[]);
    isDebug(): boolean;
    debug(message: string): void;
    log(message: string): void;
    info(message: string): void;
    notice(message: string | Error): void;
    warning(message: string | Error): void;
    error(message: string | Error): void;
    startGroup(name: string, level?: LogLevel): void;
    endGroup(level?: LogLevel): void;
}

export declare class ConsoleLogger extends BaseLogger implements RunnerLogger {
    constructor(logLevel?: LogLevel, debugEnvironmentVariables?: string[]);
    log(message: string): void;
    debug(message: string): void;
    info(message: string): void;
    notice(message: string | Error): void;
    warning(message: string | Error): void;
    error(message: string | Error): void;
    startGroup(name: string, level?: LogLevel): void;
    endGroup(level?: LogLevel): void;
}

declare enum ContentFilterMode {
    None = "none",
    Markdown = "markdown",
    HiddenCharacters = "hidden_characters"
}

export declare type ErrorOccurredHook = (input: ErrorOccurredHookInput) => Promise<ErrorOccurredHookOutput | void>;

/**
 * Error occurred hook types
 */
export declare interface ErrorOccurredHookInput extends BaseHookInput {
    error: Error;
    errorContext: "model_call" | "tool_execution" | "system" | "user_input";
    recoverable: boolean;
}

export declare interface ErrorOccurredHookOutput {
    suppressOutput?: boolean;
    errorHandling?: "retry" | "skip" | "abort";
    retryCount?: number;
    userNotification?: string;
}

export declare function executeHooks<TInput extends BaseHookInput, TOutput>(hooks: ((input: TInput) => Promise<TOutput | void>)[] | undefined, input: TInput, logger: RunnerLogger): Promise<void | TOutput>;

export declare class FileLogger extends BaseLogger implements RunnerLogger {
    private readonly filePath;
    /** Promise that resolves when pending writes are complete. Used to serialize
     * writes and for testing. */
    writeQueue: Promise<void>;
    constructor(filePath: string, logLevel?: LogLevel, debugEnvironmentVariables?: string[]);
    log(message: string): void;
    debug(message: string): void;
    info(message: string): void;
    notice(message: string | Error): void;
    warning(message: string | Error): void;
    error(message: string | Error): void;
    startGroup(name: string, level?: LogLevel): void;
    endGroup(level?: LogLevel): void;
    write(category: string, message: string): void;
    private performWrite;
}

/**
 * Returns true if the DEBUG or COPILOT_AGENT_DEBUG environment variable is set to 1 or true (case-insensitive).
 * If additionalVariables are provided, they are also checked.
 * @param additionalVariables Additional environment variables to check for debug logging.
 */
export declare function isDebugEnvironment(...additionalVariables: string[]): boolean;

export declare enum LogLevel {
    None = 0,
    Error = 1,// 1
    Warning = 2,// 2
    Info = 4,// 4
    Debug = 8,// 8
    All = 15,
    Default = 7
}

declare interface MCPInMemoryServerConfig extends MCPServerConfigBase {
    type: "memory";
    serverInstance: McpServer;
}

declare interface MCPLocalServerConfig extends MCPServerConfigBase {
    type?: "local" | "stdio";
    command: string;
    args: string[];
    /**
     * An object of the environment variables to pass to the server. Key is whats sent to the MCP Server. Value is whats read from the actions environment. Empty means no env vars passed.
     */
    env?: Record<string, string>;
}

/**
 * A permission request for invoking an MCP tool.
 */
declare type MCPPermissionRequest = {
    readonly kind: "mcp";
    /** The name of the MCP Server being targeted e.g. "github-mcp-server" */
    readonly serverName: string;
    /** The name of the tool being targeted e.g. "list_issues" */
    readonly toolName: string;
    /** The title of the tool being targeted e.g. "List Issues" */
    readonly toolTitle: string;
    /**
     * The _hopefully_ JSON arguments that will be passed to the MCP tool.
     *
     * This should be an object, but it's not parsed before this point so we can't guarantee that.
     * */
    readonly args: unknown;
    /**
     * Whether the tool is read-only (e.g. a `view` operation) or not (e.g. an `edit` operation).
     */
    readonly readOnly: boolean;
};

declare interface MCPRemoteServerConfig extends MCPServerConfigBase {
    type: "http" | "sse";
    /**
     * URL of the remote server
     * NOTE: this has to be converted to a URL object before giving to transport.
     * TransportFactory will handle this conversion.
     */
    url: string;
    /**
     * Optional. HTTP headers to include in requests to the remote server.
     * This can be used for authentication or other purposes.
     * For example, you might include an Authorization header.
     */
    headers?: Record<string, string>;
}

declare type MCPServerConfig = MCPLocalServerConfig | MCPRemoteServerConfig | MCPInMemoryServerConfig;

declare interface MCPServerConfigBase {
    /**
     * List of tools to include from this server. [] means none. "*" means all.
     */
    tools: string[];
    /**
     * Indicates "remote" or "local" server type.
     * If not specified, defaults to "local".
     */
    type?: string;
    /**
     * Optional. Denotes if this is a MCP server we have defined to be used when
     * the user has not provided their own MCP server config.
     *
     * Marked optional as configs coming from users will/should not have this set. Defaults to `false`.
     */
    isDefaultServer?: boolean;
    /**
     * Optional. Either a content filter mode for all tools from this server, or a map of tool name to content filter mode for the tool with that name.
     * If not specified, defaults to "hidden_characters"
     */
    filterMapping?: Record<string, ContentFilterMode> | ContentFilterMode;
}

export declare interface ModelProvider {
    type: "openai" | "anthropic" | "copilot";
    model: string;
}

export declare class NoopLogger extends BaseLogger implements RunnerLogger {
    constructor();
    debug(_message: string): void;
    log(_message: string): void;
    info(_message: string): void;
    notice(_message: string | Error): void;
    warning(_message: string | Error): void;
    error(_message: string | Error): void;
    startGroup(_name: string, _level?: LogLevel): void;
    endGroup(_level?: LogLevel): void;
}

/**
 * A permission request which will be used to check tool or path usage against config and/or request user approval.
 */
declare type PermissionRequest = ShellPermissionRequest | WritePermissionRequest | MCPPermissionRequest;

/**
 * The result of requesting permissions.
 */
declare type PermissionRequestResult = {
    readonly kind: "approved";
} | {
    readonly kind: "denied-by-rules";
    rules: ReadonlyArray<Rule>;
} | {
    readonly kind: "denied-no-approval-rule-and-could-not-request-from-user";
} | {
    readonly kind: "denied-interactively-by-user";
};

/**
 * This is just a type to warn that there's a good chance it's not a real path, because
 * it was _very_ heuristically parsed out of a command.
 */
declare type PossiblePath = string;

export declare type PostToolUseHook = (input: PostToolUseHookInput) => Promise<PostToolUseHookOutput | void>;

/**
 * Post-tool use hook types
 */
export declare interface PostToolUseHookInput extends BaseHookInput {
    toolName: string;
    toolArgs: unknown;
    toolResult: ToolResultExpanded;
}

export declare interface PostToolUseHookOutput {
    modifiedResult?: ToolResultExpanded;
    additionalContext?: string;
    suppressOutput?: boolean;
}

export declare type PreToolUseHook = (input: PreToolUseHookInput) => Promise<PreToolUseHookOutput | void>;

/**
 * Pre-tool use hook types
 */
export declare interface PreToolUseHookInput extends BaseHookInput {
    toolName: string;
    toolArgs: unknown;
}

export declare interface PreToolUseHookOutput {
    permissionDecision?: "allow" | "deny" | "ask";
    permissionDecisionReason?: string;
    modifiedArgs?: unknown;
    additionalContext?: string;
    suppressOutput?: boolean;
}

/**
 * Functional query API that provides a Claude Code-inspired interface.
 * This is a thin wrapper around the Agent class for simple use cases.
 *
 * @param options - Query configuration options
 * @returns AsyncGenerator of SDKEvent objects
 */
export declare function query(options: QueryOptions): AsyncIterable<SDKEvent>;

/**
 * Hook system with arrays of specific hook callbacks
 */
export declare interface QueryHooks {
    preToolUse?: PreToolUseHook[];
    postToolUse?: PostToolUseHook[];
    userPromptSubmitted?: UserPromptSubmittedHook[];
    sessionStart?: SessionStartHook[];
    sessionEnd?: SessionEndHook[];
    errorOccurred?: ErrorOccurredHook[];
}

export declare type QueryOptions = AgentOptions & {
    prompt: string;
};

/**
 * A Rule defines a pattern for matching permission requests.
 *
 * It is unfortunately generically named because it is intended to match across
 * different types of tool uses, e.g. `Shell(touch)` or `GitHubMCP(list_issues)`,
 * `view(.env-secrets)`
 */
declare type Rule = {
    /**
     * The kind of rule that should be matched e.g. `Shell` or `GitHubMCP`.
     */
    readonly kind: string;
    /**
     * If null, matches all arguments to the kind.
     */
    readonly argument: string | null;
};

export declare interface RunnerLogger {
    /**
     * Log a message ignoring the configured log level.
     * This is useful for logging messages that should always be logged, regardless of the log level.
     * @param message The message to log.
     */
    log(message: string): void;
    /**
     * Returns true if the environment is set to debug.
     * Note: This is not the same as the log level being set to debug.
     */
    isDebug(): boolean;
    /**
     * Log a debug message. This is only logged if the log level is set to debug.
     * @param message The message to log.
     */
    debug(message: string): void;
    /**
     * Log an info message. This is only logged if the log level is set to info or debug.
     * @param message The message to log.
     */
    info(message: string): void;
    /**
     * Log a notice message. This is only logged if the log level is set to warning, info, or debug,
     * but logs using the logger's info method.
     * This is useful for logging messages that are not errors, but are important enough to log on
     * less verbose log levels.
     * @param message The message to log.
     */
    notice(message: string | Error): void;
    /**
     * Log a warning message. This is only logged if the log level is set to warning, info, or debug
     * @param message The message to log.
     */
    warning(message: string | Error): void;
    /**
     * Log an error message. This is only logged if the log level is set to error, warning, info, or debug
     * @param message The message to log.
     */
    error(message: string | Error): void;
    /**
     * Log a message that starts a new group.
     * @param name The name of the group.
     * @param level The log level of the group. Defaults to info.
     */
    startGroup(name: string, level?: LogLevel): void;
    /**
     * Log a message that ends the current group.
     * @param level The log level of the group. Defaults to info.
     */
    endGroup(level?: LogLevel): void;
}

export declare type SDKCompleteEvent = {
    type: "complete";
    finalMessage?: string;
};

export declare type SDKErrorEvent = {
    type: "error";
    error: Error;
};

export declare type SDKEvent = SDKThinkingEvent | SDKMessageEvent | SDKToolUseEvent | SDKToolResultEvent | SDKErrorEvent | SDKCompleteEvent;

export declare type SDKMessageEvent = {
    type: "message";
    content: string;
    role: "assistant" | "user";
};

/**
 * SDK Event types that agents emit
 */
export declare type SDKThinkingEvent = {
    type: "thinking";
    content: string;
};

export declare type SDKToolResultEvent = {
    type: "tool_result";
    toolName: string;
    result: ToolResultExpanded;
    toolCallId?: string;
};

export declare type SDKToolUseEvent = {
    type: "tool_use";
    toolName: string;
    args: unknown;
    toolCallId?: string;
};

/**
 * Session class with event sourcing
 */
export declare class Session implements SessionMetadata {
    readonly sessionId: string;
    readonly startTime: Date;
    private events;
    private _chatMessages;
    private _selectedModel;
    protected logger: RunnerLogger;
    private eventCallbacks;
    constructor({ sessionId, startTime, logger, }?: {
        sessionId?: string;
        startTime?: Date;
        logger?: RunnerLogger;
    });
    /**
     * Create a session from existing events (for loading from file)
     * Does NOT trigger event callbacks during reconstruction
     */
    static fromEvents<T extends Session>(this: new (options: {
        sessionId: string;
        startTime: Date;
        logger: RunnerLogger;
    }) => T, { events, logger }: {
        events: SessionEvent[];
        logger?: RunnerLogger;
    }): T;
    /**
     * Add an event to the session
     * Auto-generates id, timestamp, and parentId
     */
    addEvent(eventData: Partial<Pick<SessionEvent, "id" | "timestamp" | "parentId">> & Omit<SessionEvent, "id" | "timestamp" | "parentId">): void;
    /**
     * Get all events in the session
     */
    getEvents(): readonly SessionEvent[];
    /**
     * Register an event callback
     * Returns unsubscribe function
     */
    onEvent(callback: (event: SessionEvent) => void): () => void;
    /**
     * Get all chat messages (reconstructed state)
     */
    get chatMessages(): readonly ChatCompletionMessageParam[];
    /**
     * Get selected model
     */
    get selectedModel(): string | undefined;
    /**
     * Set selected model and emit model change event
     */
    setSelectedModel(model: string): void;
    /**
     * Get chat context messages (excludes system messages)
     */
    getChatContextMessages(): ChatCompletionMessageParam[];
    /**
     * Get system context messages (only system messages)
     */
    getSystemContextMessages(): ChatCompletionMessageParam[];
    /**
     * Get the ID of the last event (for parentId chaining)
     */
    private getLastEventId;
    /**
     * Process event to update internal state (_chatMessages, _selectedModel, etc.)
     */
    private processEventForState;
    /**
     * Notify all registered event callbacks
     */
    private notifyEventCallbacks;
}

export declare type SessionEndHook = (input: SessionEndHookInput) => Promise<SessionEndHookOutput | void>;

/**
 * Session end hook types
 */
export declare interface SessionEndHookInput extends BaseHookInput {
    reason: "complete" | "error" | "abort" | "timeout" | "user_exit";
    finalMessage?: string;
    error?: Error;
}

export declare interface SessionEndHookOutput {
    suppressOutput?: boolean;
    cleanupActions?: string[];
    sessionSummary?: string;
}

/**
 * Union of all session event types
 */
declare type SessionEvent = z.infer<typeof SessionEventSchema>;

/**
 * Discriminated union of all event schemas
 */
declare const SessionEventSchema: z.ZodDiscriminatedUnion<"type", [z.ZodObject<{
    id: z.ZodString;
    timestamp: z.ZodString;
    parentId: z.ZodNullable<z.ZodString>;
    ephemeral: z.ZodOptional<z.ZodBoolean>;
} & {
    type: z.ZodLiteral<"session.start">;
    data: z.ZodObject<{
        sessionId: z.ZodString;
        version: z.ZodNumber;
        producer: z.ZodString;
        copilotVersion: z.ZodString;
        startTime: z.ZodString;
        selectedModel: z.ZodOptional<z.ZodString>;
    }, "strip", z.ZodTypeAny, {
        sessionId: string;
        version: number;
        producer: string;
        copilotVersion: string;
        startTime: string;
        selectedModel?: string | undefined;
    }, {
        sessionId: string;
        version: number;
        producer: string;
        copilotVersion: string;
        startTime: string;
        selectedModel?: string | undefined;
    }>;
}, "strip", z.ZodTypeAny, {
    data: {
        sessionId: string;
        version: number;
        producer: string;
        copilotVersion: string;
        startTime: string;
        selectedModel?: string | undefined;
    };
    id: string;
    type: "session.start";
    timestamp: string;
    parentId: string | null;
    ephemeral?: boolean | undefined;
}, {
    data: {
        sessionId: string;
        version: number;
        producer: string;
        copilotVersion: string;
        startTime: string;
        selectedModel?: string | undefined;
    };
    id: string;
    type: "session.start";
    timestamp: string;
    parentId: string | null;
    ephemeral?: boolean | undefined;
}>, z.ZodObject<{
    id: z.ZodString;
    timestamp: z.ZodString;
    parentId: z.ZodNullable<z.ZodString>;
    ephemeral: z.ZodOptional<z.ZodBoolean>;
} & {
    type: z.ZodLiteral<"session.resume">;
    data: z.ZodObject<{
        resumeTime: z.ZodString;
        eventCount: z.ZodNumber;
    }, "strip", z.ZodTypeAny, {
        resumeTime: string;
        eventCount: number;
    }, {
        resumeTime: string;
        eventCount: number;
    }>;
}, "strip", z.ZodTypeAny, {
    data: {
        resumeTime: string;
        eventCount: number;
    };
    id: string;
    type: "session.resume";
    timestamp: string;
    parentId: string | null;
    ephemeral?: boolean | undefined;
}, {
    data: {
        resumeTime: string;
        eventCount: number;
    };
    id: string;
    type: "session.resume";
    timestamp: string;
    parentId: string | null;
    ephemeral?: boolean | undefined;
}>, z.ZodObject<{
    id: z.ZodString;
    timestamp: z.ZodString;
    parentId: z.ZodNullable<z.ZodString>;
    ephemeral: z.ZodOptional<z.ZodBoolean>;
} & {
    type: z.ZodLiteral<"session.error">;
    data: z.ZodObject<{
        errorType: z.ZodString;
        message: z.ZodString;
        stack: z.ZodOptional<z.ZodString>;
    }, "strip", z.ZodTypeAny, {
        message: string;
        errorType: string;
        stack?: string | undefined;
    }, {
        message: string;
        errorType: string;
        stack?: string | undefined;
    }>;
}, "strip", z.ZodTypeAny, {
    data: {
        message: string;
        errorType: string;
        stack?: string | undefined;
    };
    id: string;
    type: "session.error";
    timestamp: string;
    parentId: string | null;
    ephemeral?: boolean | undefined;
}, {
    data: {
        message: string;
        errorType: string;
        stack?: string | undefined;
    };
    id: string;
    type: "session.error";
    timestamp: string;
    parentId: string | null;
    ephemeral?: boolean | undefined;
}>, z.ZodObject<{
    id: z.ZodString;
    timestamp: z.ZodString;
    parentId: z.ZodNullable<z.ZodString>;
    ephemeral: z.ZodOptional<z.ZodBoolean>;
} & {
    type: z.ZodLiteral<"session.info">;
    data: z.ZodObject<{
        infoType: z.ZodString;
        message: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        message: string;
        infoType: string;
    }, {
        message: string;
        infoType: string;
    }>;
}, "strip", z.ZodTypeAny, {
    data: {
        message: string;
        infoType: string;
    };
    id: string;
    type: "session.info";
    timestamp: string;
    parentId: string | null;
    ephemeral?: boolean | undefined;
}, {
    data: {
        message: string;
        infoType: string;
    };
    id: string;
    type: "session.info";
    timestamp: string;
    parentId: string | null;
    ephemeral?: boolean | undefined;
}>, z.ZodObject<{
    id: z.ZodString;
    timestamp: z.ZodString;
    parentId: z.ZodNullable<z.ZodString>;
    ephemeral: z.ZodOptional<z.ZodBoolean>;
} & {
    type: z.ZodLiteral<"session.model_change">;
    data: z.ZodObject<{
        previousModel: z.ZodOptional<z.ZodString>;
        newModel: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        newModel: string;
        previousModel?: string | undefined;
    }, {
        newModel: string;
        previousModel?: string | undefined;
    }>;
}, "strip", z.ZodTypeAny, {
    data: {
        newModel: string;
        previousModel?: string | undefined;
    };
    id: string;
    type: "session.model_change";
    timestamp: string;
    parentId: string | null;
    ephemeral?: boolean | undefined;
}, {
    data: {
        newModel: string;
        previousModel?: string | undefined;
    };
    id: string;
    type: "session.model_change";
    timestamp: string;
    parentId: string | null;
    ephemeral?: boolean | undefined;
}>, z.ZodObject<{
    id: z.ZodString;
    timestamp: z.ZodString;
    parentId: z.ZodNullable<z.ZodString>;
    ephemeral: z.ZodOptional<z.ZodBoolean>;
} & {
    type: z.ZodLiteral<"session.import_legacy">;
    data: z.ZodObject<{
        legacySession: z.ZodObject<{
            sessionId: z.ZodString;
            startTime: z.ZodString;
            chatMessages: z.ZodArray<z.ZodAny, "many">;
            timeline: z.ZodArray<z.ZodAny, "many">;
            selectedModel: z.ZodOptional<z.ZodString>;
        }, "strip", z.ZodTypeAny, {
            sessionId: string;
            startTime: string;
            chatMessages: any[];
            timeline: any[];
            selectedModel?: string | undefined;
        }, {
            sessionId: string;
            startTime: string;
            chatMessages: any[];
            timeline: any[];
            selectedModel?: string | undefined;
        }>;
        importTime: z.ZodString;
        sourceFile: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        legacySession: {
            sessionId: string;
            startTime: string;
            chatMessages: any[];
            timeline: any[];
            selectedModel?: string | undefined;
        };
        importTime: string;
        sourceFile: string;
    }, {
        legacySession: {
            sessionId: string;
            startTime: string;
            chatMessages: any[];
            timeline: any[];
            selectedModel?: string | undefined;
        };
        importTime: string;
        sourceFile: string;
    }>;
}, "strip", z.ZodTypeAny, {
    data: {
        legacySession: {
            sessionId: string;
            startTime: string;
            chatMessages: any[];
            timeline: any[];
            selectedModel?: string | undefined;
        };
        importTime: string;
        sourceFile: string;
    };
    id: string;
    type: "session.import_legacy";
    timestamp: string;
    parentId: string | null;
    ephemeral?: boolean | undefined;
}, {
    data: {
        legacySession: {
            sessionId: string;
            startTime: string;
            chatMessages: any[];
            timeline: any[];
            selectedModel?: string | undefined;
        };
        importTime: string;
        sourceFile: string;
    };
    id: string;
    type: "session.import_legacy";
    timestamp: string;
    parentId: string | null;
    ephemeral?: boolean | undefined;
}>, z.ZodObject<{
    id: z.ZodString;
    timestamp: z.ZodString;
    parentId: z.ZodNullable<z.ZodString>;
    ephemeral: z.ZodOptional<z.ZodBoolean>;
} & {
    type: z.ZodLiteral<"user.message">;
    data: z.ZodObject<{
        content: z.ZodString;
        attachments: z.ZodOptional<z.ZodArray<z.ZodObject<{
            type: z.ZodEnum<["file", "directory"]>;
            path: z.ZodString;
            displayName: z.ZodString;
        }, "strip", z.ZodTypeAny, {
            path: string;
            type: "file" | "directory";
            displayName: string;
        }, {
            path: string;
            type: "file" | "directory";
            displayName: string;
        }>, "many">>;
    }, "strip", z.ZodTypeAny, {
        content: string;
        attachments?: {
            path: string;
            type: "file" | "directory";
            displayName: string;
        }[] | undefined;
    }, {
        content: string;
        attachments?: {
            path: string;
            type: "file" | "directory";
            displayName: string;
        }[] | undefined;
    }>;
}, "strip", z.ZodTypeAny, {
    data: {
        content: string;
        attachments?: {
            path: string;
            type: "file" | "directory";
            displayName: string;
        }[] | undefined;
    };
    id: string;
    type: "user.message";
    timestamp: string;
    parentId: string | null;
    ephemeral?: boolean | undefined;
}, {
    data: {
        content: string;
        attachments?: {
            path: string;
            type: "file" | "directory";
            displayName: string;
        }[] | undefined;
    };
    id: string;
    type: "user.message";
    timestamp: string;
    parentId: string | null;
    ephemeral?: boolean | undefined;
}>, z.ZodObject<{
    id: z.ZodString;
    timestamp: z.ZodString;
    parentId: z.ZodNullable<z.ZodString>;
    ephemeral: z.ZodOptional<z.ZodBoolean>;
} & {
    type: z.ZodLiteral<"assistant.turn_start">;
    data: z.ZodObject<{
        turnId: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        turnId: string;
    }, {
        turnId: string;
    }>;
}, "strip", z.ZodTypeAny, {
    data: {
        turnId: string;
    };
    id: string;
    type: "assistant.turn_start";
    timestamp: string;
    parentId: string | null;
    ephemeral?: boolean | undefined;
}, {
    data: {
        turnId: string;
    };
    id: string;
    type: "assistant.turn_start";
    timestamp: string;
    parentId: string | null;
    ephemeral?: boolean | undefined;
}>, z.ZodObject<{
    id: z.ZodString;
    timestamp: z.ZodString;
    parentId: z.ZodNullable<z.ZodString>;
    ephemeral: z.ZodOptional<z.ZodBoolean>;
} & {
    type: z.ZodLiteral<"assistant.message">;
    data: z.ZodObject<{
        messageId: z.ZodString;
        content: z.ZodString;
        toolRequests: z.ZodOptional<z.ZodArray<z.ZodObject<{
            toolCallId: z.ZodString;
            name: z.ZodString;
            arguments: z.ZodUnknown;
        }, "strip", z.ZodTypeAny, {
            name: string;
            toolCallId: string;
            arguments?: unknown;
        }, {
            name: string;
            toolCallId: string;
            arguments?: unknown;
        }>, "many">>;
    }, "strip", z.ZodTypeAny, {
        content: string;
        messageId: string;
        toolRequests?: {
            name: string;
            toolCallId: string;
            arguments?: unknown;
        }[] | undefined;
    }, {
        content: string;
        messageId: string;
        toolRequests?: {
            name: string;
            toolCallId: string;
            arguments?: unknown;
        }[] | undefined;
    }>;
}, "strip", z.ZodTypeAny, {
    data: {
        content: string;
        messageId: string;
        toolRequests?: {
            name: string;
            toolCallId: string;
            arguments?: unknown;
        }[] | undefined;
    };
    id: string;
    type: "assistant.message";
    timestamp: string;
    parentId: string | null;
    ephemeral?: boolean | undefined;
}, {
    data: {
        content: string;
        messageId: string;
        toolRequests?: {
            name: string;
            toolCallId: string;
            arguments?: unknown;
        }[] | undefined;
    };
    id: string;
    type: "assistant.message";
    timestamp: string;
    parentId: string | null;
    ephemeral?: boolean | undefined;
}>, z.ZodObject<{
    id: z.ZodString;
    timestamp: z.ZodString;
    parentId: z.ZodNullable<z.ZodString>;
    ephemeral: z.ZodOptional<z.ZodBoolean>;
} & {
    type: z.ZodLiteral<"assistant.turn_end">;
    data: z.ZodObject<{
        turnId: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        turnId: string;
    }, {
        turnId: string;
    }>;
}, "strip", z.ZodTypeAny, {
    data: {
        turnId: string;
    };
    id: string;
    type: "assistant.turn_end";
    timestamp: string;
    parentId: string | null;
    ephemeral?: boolean | undefined;
}, {
    data: {
        turnId: string;
    };
    id: string;
    type: "assistant.turn_end";
    timestamp: string;
    parentId: string | null;
    ephemeral?: boolean | undefined;
}>, z.ZodObject<{
    id: z.ZodString;
    timestamp: z.ZodString;
    parentId: z.ZodNullable<z.ZodString>;
} & {
    type: z.ZodLiteral<"assistant.usage">;
    ephemeral: z.ZodLiteral<true>;
    data: z.ZodObject<{
        model: z.ZodOptional<z.ZodString>;
        tokensUsed: z.ZodOptional<z.ZodNumber>;
        cost: z.ZodOptional<z.ZodNumber>;
        duration: z.ZodOptional<z.ZodNumber>;
    }, "strip", z.ZodTypeAny, {
        model?: string | undefined;
        tokensUsed?: number | undefined;
        cost?: number | undefined;
        duration?: number | undefined;
    }, {
        model?: string | undefined;
        tokensUsed?: number | undefined;
        cost?: number | undefined;
        duration?: number | undefined;
    }>;
}, "strip", z.ZodTypeAny, {
    data: {
        model?: string | undefined;
        tokensUsed?: number | undefined;
        cost?: number | undefined;
        duration?: number | undefined;
    };
    id: string;
    type: "assistant.usage";
    ephemeral: true;
    timestamp: string;
    parentId: string | null;
}, {
    data: {
        model?: string | undefined;
        tokensUsed?: number | undefined;
        cost?: number | undefined;
        duration?: number | undefined;
    };
    id: string;
    type: "assistant.usage";
    ephemeral: true;
    timestamp: string;
    parentId: string | null;
}>, z.ZodObject<{
    id: z.ZodString;
    timestamp: z.ZodString;
    parentId: z.ZodNullable<z.ZodString>;
    ephemeral: z.ZodOptional<z.ZodBoolean>;
} & {
    type: z.ZodLiteral<"abort">;
    data: z.ZodObject<{
        reason: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        reason: string;
    }, {
        reason: string;
    }>;
}, "strip", z.ZodTypeAny, {
    data: {
        reason: string;
    };
    id: string;
    type: "abort";
    timestamp: string;
    parentId: string | null;
    ephemeral?: boolean | undefined;
}, {
    data: {
        reason: string;
    };
    id: string;
    type: "abort";
    timestamp: string;
    parentId: string | null;
    ephemeral?: boolean | undefined;
}>, z.ZodObject<{
    id: z.ZodString;
    timestamp: z.ZodString;
    parentId: z.ZodNullable<z.ZodString>;
    ephemeral: z.ZodOptional<z.ZodBoolean>;
} & {
    type: z.ZodLiteral<"tool.execution_start">;
    data: z.ZodObject<{
        toolCallId: z.ZodString;
        toolName: z.ZodString;
        arguments: z.ZodUnknown;
    }, "strip", z.ZodTypeAny, {
        toolCallId: string;
        toolName: string;
        arguments?: unknown;
    }, {
        toolCallId: string;
        toolName: string;
        arguments?: unknown;
    }>;
}, "strip", z.ZodTypeAny, {
    data: {
        toolCallId: string;
        toolName: string;
        arguments?: unknown;
    };
    id: string;
    type: "tool.execution_start";
    timestamp: string;
    parentId: string | null;
    ephemeral?: boolean | undefined;
}, {
    data: {
        toolCallId: string;
        toolName: string;
        arguments?: unknown;
    };
    id: string;
    type: "tool.execution_start";
    timestamp: string;
    parentId: string | null;
    ephemeral?: boolean | undefined;
}>, z.ZodObject<{
    id: z.ZodString;
    timestamp: z.ZodString;
    parentId: z.ZodNullable<z.ZodString>;
} & {
    type: z.ZodLiteral<"tool.execution_partial_result">;
    ephemeral: z.ZodLiteral<true>;
    data: z.ZodObject<{
        toolCallId: z.ZodString;
        toolName: z.ZodString;
        partialOutput: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        toolCallId: string;
        toolName: string;
        partialOutput: string;
    }, {
        toolCallId: string;
        toolName: string;
        partialOutput: string;
    }>;
}, "strip", z.ZodTypeAny, {
    data: {
        toolCallId: string;
        toolName: string;
        partialOutput: string;
    };
    id: string;
    type: "tool.execution_partial_result";
    ephemeral: true;
    timestamp: string;
    parentId: string | null;
}, {
    data: {
        toolCallId: string;
        toolName: string;
        partialOutput: string;
    };
    id: string;
    type: "tool.execution_partial_result";
    ephemeral: true;
    timestamp: string;
    parentId: string | null;
}>, z.ZodObject<{
    id: z.ZodString;
    timestamp: z.ZodString;
    parentId: z.ZodNullable<z.ZodString>;
    ephemeral: z.ZodOptional<z.ZodBoolean>;
} & {
    type: z.ZodLiteral<"tool.execution_complete">;
    data: z.ZodObject<{
        toolCallId: z.ZodString;
        toolName: z.ZodString;
        success: z.ZodBoolean;
        result: z.ZodOptional<z.ZodObject<{
            content: z.ZodString;
        }, "strip", z.ZodTypeAny, {
            content: string;
        }, {
            content: string;
        }>>;
        error: z.ZodOptional<z.ZodObject<{
            message: z.ZodString;
            code: z.ZodOptional<z.ZodString>;
        }, "strip", z.ZodTypeAny, {
            message: string;
            code?: string | undefined;
        }, {
            message: string;
            code?: string | undefined;
        }>>;
    }, "strip", z.ZodTypeAny, {
        success: boolean;
        toolCallId: string;
        toolName: string;
        result?: {
            content: string;
        } | undefined;
        error?: {
            message: string;
            code?: string | undefined;
        } | undefined;
    }, {
        success: boolean;
        toolCallId: string;
        toolName: string;
        result?: {
            content: string;
        } | undefined;
        error?: {
            message: string;
            code?: string | undefined;
        } | undefined;
    }>;
}, "strip", z.ZodTypeAny, {
    data: {
        success: boolean;
        toolCallId: string;
        toolName: string;
        result?: {
            content: string;
        } | undefined;
        error?: {
            message: string;
            code?: string | undefined;
        } | undefined;
    };
    id: string;
    type: "tool.execution_complete";
    timestamp: string;
    parentId: string | null;
    ephemeral?: boolean | undefined;
}, {
    data: {
        success: boolean;
        toolCallId: string;
        toolName: string;
        result?: {
            content: string;
        } | undefined;
        error?: {
            message: string;
            code?: string | undefined;
        } | undefined;
    };
    id: string;
    type: "tool.execution_complete";
    timestamp: string;
    parentId: string | null;
    ephemeral?: boolean | undefined;
}>, z.ZodObject<{
    id: z.ZodString;
    timestamp: z.ZodString;
    parentId: z.ZodNullable<z.ZodString>;
    ephemeral: z.ZodOptional<z.ZodBoolean>;
} & {
    type: z.ZodLiteral<"hook.start">;
    data: z.ZodObject<{
        hookInvocationId: z.ZodString;
        hookType: z.ZodString;
        input: z.ZodUnknown;
    }, "strip", z.ZodTypeAny, {
        hookInvocationId: string;
        hookType: string;
        input?: unknown;
    }, {
        hookInvocationId: string;
        hookType: string;
        input?: unknown;
    }>;
}, "strip", z.ZodTypeAny, {
    data: {
        hookInvocationId: string;
        hookType: string;
        input?: unknown;
    };
    id: string;
    type: "hook.start";
    timestamp: string;
    parentId: string | null;
    ephemeral?: boolean | undefined;
}, {
    data: {
        hookInvocationId: string;
        hookType: string;
        input?: unknown;
    };
    id: string;
    type: "hook.start";
    timestamp: string;
    parentId: string | null;
    ephemeral?: boolean | undefined;
}>, z.ZodObject<{
    id: z.ZodString;
    timestamp: z.ZodString;
    parentId: z.ZodNullable<z.ZodString>;
    ephemeral: z.ZodOptional<z.ZodBoolean>;
} & {
    type: z.ZodLiteral<"hook.end">;
    data: z.ZodObject<{
        hookInvocationId: z.ZodString;
        hookType: z.ZodString;
        output: z.ZodUnknown;
        success: z.ZodBoolean;
        error: z.ZodOptional<z.ZodObject<{
            message: z.ZodString;
            stack: z.ZodOptional<z.ZodString>;
        }, "strip", z.ZodTypeAny, {
            message: string;
            stack?: string | undefined;
        }, {
            message: string;
            stack?: string | undefined;
        }>>;
    }, "strip", z.ZodTypeAny, {
        success: boolean;
        hookInvocationId: string;
        hookType: string;
        error?: {
            message: string;
            stack?: string | undefined;
        } | undefined;
        output?: unknown;
    }, {
        success: boolean;
        hookInvocationId: string;
        hookType: string;
        error?: {
            message: string;
            stack?: string | undefined;
        } | undefined;
        output?: unknown;
    }>;
}, "strip", z.ZodTypeAny, {
    data: {
        success: boolean;
        hookInvocationId: string;
        hookType: string;
        error?: {
            message: string;
            stack?: string | undefined;
        } | undefined;
        output?: unknown;
    };
    id: string;
    type: "hook.end";
    timestamp: string;
    parentId: string | null;
    ephemeral?: boolean | undefined;
}, {
    data: {
        success: boolean;
        hookInvocationId: string;
        hookType: string;
        error?: {
            message: string;
            stack?: string | undefined;
        } | undefined;
        output?: unknown;
    };
    id: string;
    type: "hook.end";
    timestamp: string;
    parentId: string | null;
    ephemeral?: boolean | undefined;
}>, z.ZodObject<{
    id: z.ZodString;
    timestamp: z.ZodString;
    parentId: z.ZodNullable<z.ZodString>;
    ephemeral: z.ZodOptional<z.ZodBoolean>;
} & {
    type: z.ZodLiteral<"system.message">;
    data: z.ZodObject<{
        content: z.ZodString;
        role: z.ZodEnum<["system", "developer"]>;
        name: z.ZodOptional<z.ZodString>;
        metadata: z.ZodOptional<z.ZodObject<{
            promptVersion: z.ZodOptional<z.ZodString>;
            variables: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodUnknown>>;
        }, "strip", z.ZodTypeAny, {
            promptVersion?: string | undefined;
            variables?: Record<string, unknown> | undefined;
        }, {
            promptVersion?: string | undefined;
            variables?: Record<string, unknown> | undefined;
        }>>;
    }, "strip", z.ZodTypeAny, {
        role: "developer" | "system";
        content: string;
        name?: string | undefined;
        metadata?: {
            promptVersion?: string | undefined;
            variables?: Record<string, unknown> | undefined;
        } | undefined;
    }, {
        role: "developer" | "system";
        content: string;
        name?: string | undefined;
        metadata?: {
            promptVersion?: string | undefined;
            variables?: Record<string, unknown> | undefined;
        } | undefined;
    }>;
}, "strip", z.ZodTypeAny, {
    data: {
        role: "developer" | "system";
        content: string;
        name?: string | undefined;
        metadata?: {
            promptVersion?: string | undefined;
            variables?: Record<string, unknown> | undefined;
        } | undefined;
    };
    id: string;
    type: "system.message";
    timestamp: string;
    parentId: string | null;
    ephemeral?: boolean | undefined;
}, {
    data: {
        role: "developer" | "system";
        content: string;
        name?: string | undefined;
        metadata?: {
            promptVersion?: string | undefined;
            variables?: Record<string, unknown> | undefined;
        } | undefined;
    };
    id: string;
    type: "system.message";
    timestamp: string;
    parentId: string | null;
    ephemeral?: boolean | undefined;
}>]>;

/**
 * Base SessionManager - manages sessions in memory without persistence.
 * Generic type TSession allows subclasses to work with specific Session types.
 */
export declare class SessionManager<TSession extends Session = Session> {
    protected sessions: Map<string, TSession>;
    protected logger: RunnerLogger;
    private lastAccessedSessionId;
    constructor({ logger }?: SessionManagerOptions);
    /**
     * Create a new session in memory
     */
    createSession(): Promise<TSession>;
    /**
     * Get existing session by ID
     */
    getSession(sessionId: string): Promise<TSession | undefined>;
    /**
     * Get the most recently created or accessed session
     */
    getLastSession(): Promise<TSession | undefined>;
    /**
     * List all sessions with their metadata
     */
    listSessions(): Promise<SessionMetadata[]>;
    /**
     * Save session state immediately
     * Base class does nothing (no persistence)
     */
    saveSession(_session: TSession): Promise<void>;
    /**
     * Delete session from memory
     */
    deleteSession(session: TSession): Promise<void>;
}

export declare interface SessionManagerOptions {
    /**
     * Logger instance for the session manager
     */
    logger?: RunnerLogger;
}

export declare interface SessionMetadata {
    readonly sessionId: string;
    readonly startTime: Date;
}

export declare type SessionStartHook = (input: SessionStartHookInput) => Promise<SessionStartHookOutput | void>;

/**
 * Session start hook types
 */
export declare interface SessionStartHookInput extends BaseHookInput {
    source: "startup" | "resume" | "new";
    initialPrompt?: string;
}

export declare interface SessionStartHookOutput {
    additionalContext?: string;
    modifiedConfig?: Record<string, unknown>;
}

/**
 * A permission request for executing shell commands.
 */
declare type ShellPermissionRequest = {
    readonly kind: "shell";
    /** The full command that the user is being asked to approve, e.g. `echo foo && find -exec ... && git push` */
    readonly fullCommandText: string;
    /** A concise summary of the user's intention, e.g. "Echo foo and find a file and then run git push" */
    readonly intention: string;
    /**
     * The commands that are being invoked in the shell invocation.
     *
     * As a special case, which might be better represented in the type system, if there were no parsed commands
     * e.g. `export VAR=value`, then this will have a single entry with identifier equal to the fullCommandText.
     */
    readonly commands: ReadonlyArray<Command>;
    /**
     * Possible file paths that the command might access.
     *
     * This is entirely heuristic, so it's pretty untrustworthy.
     */
    readonly possiblePaths: ReadonlyArray<PossiblePath>;
    /**
     * Indicates whether any command in the script has redirection to write to a file.
     */
    readonly hasWriteFileRedirection: boolean;
    /**
     * If there are complicated constructs, then persistent approval is not supported.
     * e.g. `cat $(echo "foo")` should not be persistently approvable because it's hard
     * for the user to understand the implications.
     */
    readonly canOfferSessionApproval: boolean;
};

/**
 * Telemetry emitted by the runtime contains properties and metrics. These are non-sensitive pieces
 * of information. There are also restricted properties that must be used to store sensitive information.
 */
declare type Telemetry = {
    /**
     * Telemetry properties can be used to store string props.
     * WARNING: Do not put sensitive data here. Use restrictedProperties for that.
     */
    properties: Record<string, string | undefined>;
    /**
     * Restricted telemetry properties must be used to store sensitive string props. These props will only be available on the restricted kusto topics.
     * Nonnullable so it is harder to overlook.
     */
    restrictedProperties: Record<string, string | undefined>;
    /**
     * The name of the telemetry event associated with the emitted runtime event.
     */
    metrics: Record<string, number | undefined>;
};

declare type ToolResultExpanded<TelemetryT extends Telemetry = Telemetry> = {
    /**
     * The result to be given back to the LLM.
     *
     * If @see sessionLog is omitted, then this will be used as the session log.
     */
    textResultForLlm: string;
    /**
     * The result to be given back to the LLM. It can be either base64 encoded image or audio content.
     */
    binaryResultForLlm?: BinaryResult[];
    /**
     * Whether or not the result should be considered a success, failure, or previously interrupted.
     * - `success`: The tool executed successfully and produced a valid result.
     * - `failure`: The tool encountered an error or did not produce a valid result.
     * - `rejected`: The tool call was rejected either because the user didn't want this call, or a previous dependent one.
     * - `denied`: The tool call was denied because the permissions service said no.
     */
    resultType: "success" | "failure" | "rejected" | "denied";
    /**
     * If there was any sort of error that caused the tool to fail, then a string representation of the error. Typically
     * only set if {@link resultType} is `'failure'`.
     */
    error?: string;
    /**
     * Specific telemetry for the tool. Will be sent back to the server by the agent.
     */
    toolTelemetry: {
        properties?: TelemetryT["properties"];
        restrictedProperties?: TelemetryT["restrictedProperties"];
        metrics?: TelemetryT["metrics"];
    };
    /**
     * Well-formatted (typically Markdown) string that can be used to display the input/output of the tool invoked.
     *
     * (Optional) If omitted, the text result for the LLM will be used as the session log.
     */
    sessionLog?: string;
};

export declare type UserPromptSubmittedHook = (input: UserPromptSubmittedHookInput) => Promise<UserPromptSubmittedHookOutput | void>;

/**
 * User prompt submitted hook types
 */
export declare interface UserPromptSubmittedHookInput extends BaseHookInput {
    prompt: string;
}

export declare interface UserPromptSubmittedHookOutput {
    modifiedPrompt?: string;
    additionalContext?: string;
    suppressOutput?: boolean;
}

/**
 * A permission request for writing to new or existing files.
 */
declare type WritePermissionRequest = {
    readonly kind: "write";
    /** The intention of the edit operation, e.g. "Edit file" or "Create file" */
    readonly intention: string;
    /** The name of the file being edited */
    readonly fileName: string;
    /** The diff of the changes being made */
    readonly diff: string;
};

export { }
